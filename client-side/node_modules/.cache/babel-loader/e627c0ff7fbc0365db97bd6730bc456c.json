{"ast":null,"code":"import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext, useStore } from 'react-redux';\nimport invariant from 'invariant';\nimport isEmpty from 'lodash/isEmpty';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport conformsTo from 'lodash/conformsTo';\nimport isObject from 'lodash/isObject';\nimport isNumber from 'lodash/isNumber';\n\n/**\n * Forces a reload of the injected reducers. i.e. Causes `createReducer` to be\n * called again with the injected reducers. Useful for hot-reloading.\n *\n * @param store The redux store that has been configured with\n *                  `createInjectorsEnhancer`\n * @example\n * forceReducerReload(store);\n *\n * @public\n */\nfunction forceReducerReload(store) {\n  store.replaceReducer(store.createReducer(store.injectedReducers));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Validates the redux store is set up properly to work with this library.\n */\n\nfunction checkStore(store) {\n  var shape = {\n    dispatch: isFunction,\n    subscribe: isFunction,\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    createReducer: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject\n  };\n  invariant(conformsTo(store, shape), '(redux-injectors...) checkStore: Expected a redux store that has been configured for use with redux-injectors.');\n}\nfunction injectReducerFactory(store, isValid) {\n  return function injectReducer(key, reducer) {\n    if (!isValid) checkStore(store);\n    invariant(isString(key) && !isEmpty(key) && isFunction(reducer), '(redux-injectors...) injectReducer: Expected `reducer` to be a reducer function'); // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\n\n    if (Reflect.has(store.injectedReducers, key) && store.injectedReducers[key] === reducer) return;\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\n\n    store.replaceReducer(store.createReducer(store.injectedReducers));\n  };\n}\nfunction getInjectors(store) {\n  checkStore(store);\n  return {\n    injectReducer: injectReducerFactory(store, true)\n  };\n}\n\n/**\n * A higher-order component that dynamically injects a reducer when the\n * component is instantiated\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *   render() {\n *     return null;\n *   }\n * }\n *\n * export default injectReducer({ key: \"books\", reducer: booksReducer })(BooksManager)\n *\n * @public\n */\n\nvar injectReducer = function (_ref) {\n  var key = _ref.key,\n    reducer = _ref.reducer;\n  return function (WrappedComponent) {\n    var ReducerInjector = /*#__PURE__*/function (_React$Component) {\n      _inherits(ReducerInjector, _React$Component);\n      var _super = _createSuper(ReducerInjector);\n      function ReducerInjector(props, context) {\n        var _this;\n        _classCallCheck(this, ReducerInjector);\n        _this = _super.call(this, props, context);\n        getInjectors(context.store).injectReducer(key, reducer);\n        return _this;\n      }\n      _createClass(ReducerInjector, [{\n        key: \"render\",\n        value: function render() {\n          return /*#__PURE__*/React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n      return ReducerInjector;\n    }(React.Component);\n    _defineProperty(ReducerInjector, \"WrappedComponent\", WrappedComponent);\n    _defineProperty(ReducerInjector, \"contextType\", ReactReduxContext);\n    _defineProperty(ReducerInjector, \"displayName\", \"withReducer(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n    return hoistNonReactStatics(ReducerInjector, WrappedComponent);\n  };\n};\n/**\n * A react hook that dynamically injects a reducer when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectReducer({ key: \"books\", reducer: booksReducer })\n *\n *   return null;\n * }\n *\n * @returns {boolean} flag indicating whether or not the reducer has finished injecting\n * @public\n */\n\nvar useInjectReducer = function useInjectReducer(_ref2) {\n  var key = _ref2.key,\n    reducer = _ref2.reducer;\n  var store = useStore();\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    isInjected = _React$useState2[0],\n    setIsInjected = _React$useState2[1];\n  React.useLayoutEffect(function () {\n    getInjectors(store).injectReducer(key, reducer);\n    setIsInjected(true);\n  }, []);\n  return isInjected;\n};\nvar RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\nvar DAEMON = '@@saga-injector/daemon';\nvar ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';\nvar COUNTER = '@@saga-injector/counter';\n/**\n * An enum of all the possible saga injection behaviours\n *\n * @property {String} RESTART_ON_REMOUNT The saga will be started on component instantiation and cancelled with\n * `task.cancel()` on component unmount for improved performance.\n * @property {String} DAEMON Causes the saga to be started on component instantiation and never canceled\n * or started again.\n * @property {String} ONCE_TILL_UNMOUNT Behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n * @property {String} COUNTER Similar to 'RESTART_ON_REMOUNT' except the\n * saga will be mounted only once on first inject and ejected when all injectors are unmounted.\n * This enables you to have multiple injectors with the same saga and key and only one instance of the saga will run.\n *\n * @enum\n * @public\n */\n\nvar SagaInjectionModes = {\n  RESTART_ON_REMOUNT: RESTART_ON_REMOUNT,\n  DAEMON: DAEMON,\n  ONCE_TILL_UNMOUNT: ONCE_TILL_UNMOUNT,\n  COUNTER: COUNTER\n};\nvar allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT, COUNTER];\nvar checkKey = function checkKey(key) {\n  return invariant(isString(key) && !isEmpty(key), '(redux-injectors...) injectSaga: Expected `key` to be a non empty string');\n};\nvar checkDescriptor = function checkDescriptor(descriptor) {\n  var shape = {\n    saga: isFunction,\n    mode: function mode(_mode) {\n      return isString(_mode) && allowedModes.includes(_mode);\n    },\n    count: isNumber\n  };\n  invariant(conformsTo(descriptor, shape), '(redux-injectors...) injectSaga: Expected a valid saga descriptor');\n};\nfunction injectSagaFactory(store, isValid) {\n  return function injectSaga(key) {\n    var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isValid) checkStore(store);\n    var newDescriptor = _objectSpread2({}, descriptor, {\n      mode: descriptor.mode || DAEMON,\n      count: 0\n    });\n    var saga = newDescriptor.saga,\n      mode = newDescriptor.mode;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    var hasSaga = Reflect.has(store.injectedSagas, key);\n    if (process.env.NODE_ENV !== 'production') {\n      var oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n    if (mode === COUNTER) {\n      // COUNTER must be added if saga is done\n      if (store.injectedSagas[key] === 'done') hasSaga = false;\n      var oldCounterValue = 0;\n      if (hasSaga) {\n        oldCounterValue = Math.max(store.injectedSagas[key].count || 0, 0);\n      }\n      newDescriptor.count = oldCounterValue + 1;\n    }\n    if (!hasSaga || hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT && mode !== COUNTER) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = _objectSpread2({}, newDescriptor, {\n        task: store.runSaga(saga)\n      });\n      /* eslint-enable no-param-reassign */\n    } else if (hasSaga && mode === COUNTER) {\n      // increment num of sagas that wants to be injected\n\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key].count = newDescriptor.count;\n    }\n  };\n}\nfunction ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n    checkKey(key);\n    if (Reflect.has(store.injectedSagas, key)) {\n      var descriptor = store.injectedSagas[key];\n      if (!descriptor.mode) {\n        return;\n      }\n      if (descriptor.mode === COUNTER) {\n        descriptor.count -= 1;\n        if (descriptor.count > 0) return;\n        descriptor.task.cancel();\n        delete store.injectedSagas[key];\n      } else if (descriptor.mode !== DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\n\nfunction getInjectors$1(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}\n\n/**\n * A higher-order component that dynamically injects a saga when the component\n * is instantiated. There are several possible \"modes\" / \"behaviours\" that\n * dictate how and when the saga should be injected and ejected\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n * @param {string} [params.mode] The injection behaviour to use. The default is\n * `SagaInjectionModes.DAEMON` which causes the saga to be started on component\n * instantiation and never canceled or started again. @see\n * {@link SagaInjectionModes} for the other possible modes.\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *  render() {\n *    return null;\n *  }\n * }\n *\n * export default injectSaga({ key: \"books\", saga: booksSaga })(BooksManager)\n *\n * @public\n *\n */\n\nvar injectSaga = function (_ref) {\n  var key = _ref.key,\n    saga = _ref.saga,\n    mode = _ref.mode;\n  return function (WrappedComponent) {\n    var InjectSaga = /*#__PURE__*/function (_React$Component) {\n      _inherits(InjectSaga, _React$Component);\n      var _super = _createSuper(InjectSaga);\n      function InjectSaga(props, context) {\n        var _this;\n        _classCallCheck(this, InjectSaga);\n        _this = _super.call(this, props, context);\n        _this.injectors = getInjectors$1(context.store);\n        _this.injectors.injectSaga(key, {\n          saga: saga,\n          mode: mode\n        });\n        return _this;\n      }\n      _createClass(InjectSaga, [{\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.injectors.ejectSaga(key);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return /*#__PURE__*/React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n      return InjectSaga;\n    }(React.Component);\n    _defineProperty(InjectSaga, \"WrappedComponent\", WrappedComponent);\n    _defineProperty(InjectSaga, \"contextType\", ReactReduxContext);\n    _defineProperty(InjectSaga, \"displayName\", \"withSaga(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n    return hoistNonReactStatics(InjectSaga, WrappedComponent);\n  };\n};\n/**\n * A react hook that dynamically injects a saga when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectSaga({ key: \"books\", saga: booksSaga })\n *\n *   return null;\n * }\n *\n * @returns {boolean} flag indicating whether or not the saga has finished injecting\n * @public\n */\n\nvar useInjectSaga = function useInjectSaga(_ref2) {\n  var key = _ref2.key,\n    saga = _ref2.saga;\n  var store = useStore();\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    isInjected = _React$useState2[0],\n    setIsInjected = _React$useState2[1];\n  React.useLayoutEffect(function () {\n    getInjectors$1(store).injectSaga(key, {\n      saga: saga,\n      mode: SagaInjectionModes.COUNTER\n    });\n    setIsInjected(true);\n    return function () {\n      getInjectors$1(store).ejectSaga(key);\n    };\n  }, []);\n  return isInjected;\n};\n\n/**\n * Creates a store enhancer that when applied will setup the store to allow the\n * injectors to work properly\n *\n * @param {Object} params\n * @param {function} params.runSaga A function that runs a saga. Should usually be `sagaMiddleware.run`\n * @param {function} params.createReducer A function that should create and\n * return the root reducer. It's passed the injected reducers as the first\n * parameter. These should be added to the root reducer using `combineReducer`\n * or a similar method.\n *\n * @example\n *\n * import { createStore } from \"redux\"\n * import { createInjectorsEnhancer } from \"redux-injectors\"\n *\n * function createReducer(injectedReducers = {}) {\n *  const rootReducer = combineReducers({\n *    ...injectedReducers,\n *    // other non-injected reducers can go here...\n *  });\n *\n *  return rootReducer\n * }\n * const runSaga = sagaMiddleware.run\n *\n * const store = createStore(\n *   createReducer(),\n *   initialState,\n *   createInjectorsEnhancer({\n *     createReducer,\n *     runSaga,\n *   })\n * )\n *\n * @public\n */\n\nfunction createInjectorsEnhancer(params) {\n  invariant(conformsTo(params, {\n    runSaga: isFunction,\n    createReducer: isFunction\n  }), '(redux-injectors...) createInjectorsEnhancer: params `runSaga` and ' + '`createReducer` are required.');\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n      return _objectSpread2({}, store, {\n        createReducer: params.createReducer,\n        runSaga: params.runSaga,\n        injectedReducers: {},\n        // Reducer registry\n        injectedSagas: {} // Saga registry\n      });\n    };\n  };\n}\n\n/**\n * Creates a \"manager\" component that will inject the provided reducer and saga\n * when mounted.  It only renders its children after both the reducer and saga\n * have been injected.  This is the recommended way to use redux-injectors.\n *\n * @param {Object} options\n * @param {function} options.name The name to give the manager that shows up in the react devtools\n * @param {string} options.key The key to inject the reducer under\n * @param {function} options.reducer The reducer that will be injected\n * @param {function} options.saga The saga that will be injected\n *\n * @example\n *\n * const BooksManager = createManager({ name: \"BooksManager\", key: \"books\", reducer: booksReducer, saga: booksSaga })\n *\n * @returns {ComponentType<{ children: ReactNode }>} The manager\n * @public\n */\n\nfunction createManager(_ref) {\n  var name = _ref.name,\n    key = _ref.key,\n    reducer = _ref.reducer,\n    saga = _ref.saga;\n  function Manager(props) {\n    /* eslint-disable react-hooks/rules-of-hooks */\n    var isReducerInjected = reducer ? useInjectReducer({\n      key: key,\n      reducer: reducer\n    }) : true;\n    var isSagaInjected = saga ? useInjectSaga({\n      key: key,\n      saga: saga\n    }) : true;\n    /* eslint-enable */\n\n    return isReducerInjected && isSagaInjected ? props.children : null;\n  }\n  Manager.displayName = name;\n  return Manager;\n}\nexport { SagaInjectionModes, createInjectorsEnhancer, createManager, forceReducerReload, injectReducer, injectSaga, useInjectReducer, useInjectSaga };","map":{"version":3,"names":["React","hoistNonReactStatics","ReactReduxContext","useStore","invariant","isEmpty","isFunction","isString","conformsTo","isObject","isNumber","forceReducerReload","store","replaceReducer","createReducer","injectedReducers","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_inherits","subClass","superClass","create","constructor","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","call","e","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","Super","result","NewTarget","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","Array","isArray","Symbol","iterator","_arr","_n","_d","_e","undefined","_i","_s","next","done","err","minLen","_arrayLikeToArray","n","slice","name","from","test","len","arr2","checkStore","shape","dispatch","subscribe","getState","runSaga","injectedSagas","injectReducerFactory","isValid","injectReducer","reducer","has","getInjectors","_ref","WrappedComponent","ReducerInjector","_React$Component","_super","context","_this","render","createElement","Component","concat","displayName","useInjectReducer","_ref2","_React$useState","useState","_React$useState2","isInjected","setIsInjected","useLayoutEffect","RESTART_ON_REMOUNT","DAEMON","ONCE_TILL_UNMOUNT","COUNTER","SagaInjectionModes","allowedModes","checkKey","checkDescriptor","saga","mode","_mode","includes","count","injectSagaFactory","injectSaga","newDescriptor","hasSaga","process","env","NODE_ENV","oldDescriptor","task","cancel","oldCounterValue","Math","max","ejectSagaFactory","ejectSaga","getInjectors$1","InjectSaga","injectors","componentWillUnmount","useInjectSaga","createInjectorsEnhancer","params","createStore","createManager","Manager","isReducerInjected","isSagaInjected","children"],"sources":["D:/Github/multi-channel-project/multi-channel-frontend/node_modules/redux-injectors/dist/index.esm.js"],"sourcesContent":["import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext, useStore } from 'react-redux';\nimport invariant from 'invariant';\nimport isEmpty from 'lodash/isEmpty';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport conformsTo from 'lodash/conformsTo';\nimport isObject from 'lodash/isObject';\nimport isNumber from 'lodash/isNumber';\n\n/**\n * Forces a reload of the injected reducers. i.e. Causes `createReducer` to be\n * called again with the injected reducers. Useful for hot-reloading.\n *\n * @param store The redux store that has been configured with\n *                  `createInjectorsEnhancer`\n * @example\n * forceReducerReload(store);\n *\n * @public\n */\nfunction forceReducerReload(store) {\n  store.replaceReducer(store.createReducer(store.injectedReducers));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Validates the redux store is set up properly to work with this library.\n */\n\nfunction checkStore(store) {\n  var shape = {\n    dispatch: isFunction,\n    subscribe: isFunction,\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    createReducer: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject\n  };\n  invariant(conformsTo(store, shape), '(redux-injectors...) checkStore: Expected a redux store that has been configured for use with redux-injectors.');\n}\n\nfunction injectReducerFactory(store, isValid) {\n  return function injectReducer(key, reducer) {\n    if (!isValid) checkStore(store);\n    invariant(isString(key) && !isEmpty(key) && isFunction(reducer), '(redux-injectors...) injectReducer: Expected `reducer` to be a reducer function'); // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\n\n    if (Reflect.has(store.injectedReducers, key) && store.injectedReducers[key] === reducer) return;\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\n\n    store.replaceReducer(store.createReducer(store.injectedReducers));\n  };\n}\nfunction getInjectors(store) {\n  checkStore(store);\n  return {\n    injectReducer: injectReducerFactory(store, true)\n  };\n}\n\n/**\n * A higher-order component that dynamically injects a reducer when the\n * component is instantiated\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *   render() {\n *     return null;\n *   }\n * }\n *\n * export default injectReducer({ key: \"books\", reducer: booksReducer })(BooksManager)\n *\n * @public\n */\n\nvar injectReducer = (function (_ref) {\n  var key = _ref.key,\n      reducer = _ref.reducer;\n  return function (WrappedComponent) {\n    var ReducerInjector = /*#__PURE__*/function (_React$Component) {\n      _inherits(ReducerInjector, _React$Component);\n\n      var _super = _createSuper(ReducerInjector);\n\n      function ReducerInjector(props, context) {\n        var _this;\n\n        _classCallCheck(this, ReducerInjector);\n\n        _this = _super.call(this, props, context);\n        getInjectors(context.store).injectReducer(key, reducer);\n        return _this;\n      }\n\n      _createClass(ReducerInjector, [{\n        key: \"render\",\n        value: function render() {\n          return /*#__PURE__*/React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n\n      return ReducerInjector;\n    }(React.Component);\n\n    _defineProperty(ReducerInjector, \"WrappedComponent\", WrappedComponent);\n\n    _defineProperty(ReducerInjector, \"contextType\", ReactReduxContext);\n\n    _defineProperty(ReducerInjector, \"displayName\", \"withReducer(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n\n    return hoistNonReactStatics(ReducerInjector, WrappedComponent);\n  };\n});\n/**\n * A react hook that dynamically injects a reducer when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectReducer({ key: \"books\", reducer: booksReducer })\n *\n *   return null;\n * }\n *\n * @returns {boolean} flag indicating whether or not the reducer has finished injecting\n * @public\n */\n\nvar useInjectReducer = function useInjectReducer(_ref2) {\n  var key = _ref2.key,\n      reducer = _ref2.reducer;\n  var store = useStore();\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      isInjected = _React$useState2[0],\n      setIsInjected = _React$useState2[1];\n\n  React.useLayoutEffect(function () {\n    getInjectors(store).injectReducer(key, reducer);\n    setIsInjected(true);\n  }, []);\n  return isInjected;\n};\n\nvar RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\nvar DAEMON = '@@saga-injector/daemon';\nvar ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';\nvar COUNTER = '@@saga-injector/counter';\n/**\n * An enum of all the possible saga injection behaviours\n *\n * @property {String} RESTART_ON_REMOUNT The saga will be started on component instantiation and cancelled with\n * `task.cancel()` on component unmount for improved performance.\n * @property {String} DAEMON Causes the saga to be started on component instantiation and never canceled\n * or started again.\n * @property {String} ONCE_TILL_UNMOUNT Behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n * @property {String} COUNTER Similar to 'RESTART_ON_REMOUNT' except the\n * saga will be mounted only once on first inject and ejected when all injectors are unmounted.\n * This enables you to have multiple injectors with the same saga and key and only one instance of the saga will run.\n *\n * @enum\n * @public\n */\n\nvar SagaInjectionModes = {\n  RESTART_ON_REMOUNT: RESTART_ON_REMOUNT,\n  DAEMON: DAEMON,\n  ONCE_TILL_UNMOUNT: ONCE_TILL_UNMOUNT,\n  COUNTER: COUNTER\n};\n\nvar allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT, COUNTER];\n\nvar checkKey = function checkKey(key) {\n  return invariant(isString(key) && !isEmpty(key), '(redux-injectors...) injectSaga: Expected `key` to be a non empty string');\n};\n\nvar checkDescriptor = function checkDescriptor(descriptor) {\n  var shape = {\n    saga: isFunction,\n    mode: function mode(_mode) {\n      return isString(_mode) && allowedModes.includes(_mode);\n    },\n    count: isNumber\n  };\n  invariant(conformsTo(descriptor, shape), '(redux-injectors...) injectSaga: Expected a valid saga descriptor');\n};\n\nfunction injectSagaFactory(store, isValid) {\n  return function injectSaga(key) {\n    var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isValid) checkStore(store);\n\n    var newDescriptor = _objectSpread2({}, descriptor, {\n      mode: descriptor.mode || DAEMON,\n      count: 0\n    });\n\n    var saga = newDescriptor.saga,\n        mode = newDescriptor.mode;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    var hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      var oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (mode === COUNTER) {\n      // COUNTER must be added if saga is done\n      if (store.injectedSagas[key] === 'done') hasSaga = false;\n      var oldCounterValue = 0;\n\n      if (hasSaga) {\n        oldCounterValue = Math.max(store.injectedSagas[key].count || 0, 0);\n      }\n\n      newDescriptor.count = oldCounterValue + 1;\n    }\n\n    if (!hasSaga || hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT && mode !== COUNTER) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = _objectSpread2({}, newDescriptor, {\n        task: store.runSaga(saga)\n      });\n      /* eslint-enable no-param-reassign */\n    } else if (hasSaga && mode === COUNTER) {\n      // increment num of sagas that wants to be injected\n\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key].count = newDescriptor.count;\n    }\n  };\n}\nfunction ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      var descriptor = store.injectedSagas[key];\n\n      if (!descriptor.mode) {\n        return;\n      }\n\n      if (descriptor.mode === COUNTER) {\n        descriptor.count -= 1;\n        if (descriptor.count > 0) return;\n        descriptor.task.cancel();\n        delete store.injectedSagas[key];\n      } else if (descriptor.mode !== DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\nfunction getInjectors$1(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}\n\n/**\n * A higher-order component that dynamically injects a saga when the component\n * is instantiated. There are several possible \"modes\" / \"behaviours\" that\n * dictate how and when the saga should be injected and ejected\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n * @param {string} [params.mode] The injection behaviour to use. The default is\n * `SagaInjectionModes.DAEMON` which causes the saga to be started on component\n * instantiation and never canceled or started again. @see\n * {@link SagaInjectionModes} for the other possible modes.\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *  render() {\n *    return null;\n *  }\n * }\n *\n * export default injectSaga({ key: \"books\", saga: booksSaga })(BooksManager)\n *\n * @public\n *\n */\n\nvar injectSaga = (function (_ref) {\n  var key = _ref.key,\n      saga = _ref.saga,\n      mode = _ref.mode;\n  return function (WrappedComponent) {\n    var InjectSaga = /*#__PURE__*/function (_React$Component) {\n      _inherits(InjectSaga, _React$Component);\n\n      var _super = _createSuper(InjectSaga);\n\n      function InjectSaga(props, context) {\n        var _this;\n\n        _classCallCheck(this, InjectSaga);\n\n        _this = _super.call(this, props, context);\n        _this.injectors = getInjectors$1(context.store);\n\n        _this.injectors.injectSaga(key, {\n          saga: saga,\n          mode: mode\n        });\n\n        return _this;\n      }\n\n      _createClass(InjectSaga, [{\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.injectors.ejectSaga(key);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return /*#__PURE__*/React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n\n      return InjectSaga;\n    }(React.Component);\n\n    _defineProperty(InjectSaga, \"WrappedComponent\", WrappedComponent);\n\n    _defineProperty(InjectSaga, \"contextType\", ReactReduxContext);\n\n    _defineProperty(InjectSaga, \"displayName\", \"withSaga(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n\n    return hoistNonReactStatics(InjectSaga, WrappedComponent);\n  };\n});\n/**\n * A react hook that dynamically injects a saga when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectSaga({ key: \"books\", saga: booksSaga })\n *\n *   return null;\n * }\n *\n * @returns {boolean} flag indicating whether or not the saga has finished injecting\n * @public\n */\n\nvar useInjectSaga = function useInjectSaga(_ref2) {\n  var key = _ref2.key,\n      saga = _ref2.saga;\n  var store = useStore();\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      isInjected = _React$useState2[0],\n      setIsInjected = _React$useState2[1];\n\n  React.useLayoutEffect(function () {\n    getInjectors$1(store).injectSaga(key, {\n      saga: saga,\n      mode: SagaInjectionModes.COUNTER\n    });\n    setIsInjected(true);\n    return function () {\n      getInjectors$1(store).ejectSaga(key);\n    };\n  }, []);\n  return isInjected;\n};\n\n/**\n * Creates a store enhancer that when applied will setup the store to allow the\n * injectors to work properly\n *\n * @param {Object} params\n * @param {function} params.runSaga A function that runs a saga. Should usually be `sagaMiddleware.run`\n * @param {function} params.createReducer A function that should create and\n * return the root reducer. It's passed the injected reducers as the first\n * parameter. These should be added to the root reducer using `combineReducer`\n * or a similar method.\n *\n * @example\n *\n * import { createStore } from \"redux\"\n * import { createInjectorsEnhancer } from \"redux-injectors\"\n *\n * function createReducer(injectedReducers = {}) {\n *  const rootReducer = combineReducers({\n *    ...injectedReducers,\n *    // other non-injected reducers can go here...\n *  });\n *\n *  return rootReducer\n * }\n * const runSaga = sagaMiddleware.run\n *\n * const store = createStore(\n *   createReducer(),\n *   initialState,\n *   createInjectorsEnhancer({\n *     createReducer,\n *     runSaga,\n *   })\n * )\n *\n * @public\n */\n\nfunction createInjectorsEnhancer(params) {\n  invariant(conformsTo(params, {\n    runSaga: isFunction,\n    createReducer: isFunction\n  }), '(redux-injectors...) createInjectorsEnhancer: params `runSaga` and ' + '`createReducer` are required.');\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n      return _objectSpread2({}, store, {\n        createReducer: params.createReducer,\n        runSaga: params.runSaga,\n        injectedReducers: {},\n        // Reducer registry\n        injectedSagas: {} // Saga registry\n\n      });\n    };\n  };\n}\n\n/**\n * Creates a \"manager\" component that will inject the provided reducer and saga\n * when mounted.  It only renders its children after both the reducer and saga\n * have been injected.  This is the recommended way to use redux-injectors.\n *\n * @param {Object} options\n * @param {function} options.name The name to give the manager that shows up in the react devtools\n * @param {string} options.key The key to inject the reducer under\n * @param {function} options.reducer The reducer that will be injected\n * @param {function} options.saga The saga that will be injected\n *\n * @example\n *\n * const BooksManager = createManager({ name: \"BooksManager\", key: \"books\", reducer: booksReducer, saga: booksSaga })\n *\n * @returns {ComponentType<{ children: ReactNode }>} The manager\n * @public\n */\n\nfunction createManager(_ref) {\n  var name = _ref.name,\n      key = _ref.key,\n      reducer = _ref.reducer,\n      saga = _ref.saga;\n\n  function Manager(props) {\n    /* eslint-disable react-hooks/rules-of-hooks */\n    var isReducerInjected = reducer ? useInjectReducer({\n      key: key,\n      reducer: reducer\n    }) : true;\n    var isSagaInjected = saga ? useInjectSaga({\n      key: key,\n      saga: saga\n    }) : true;\n    /* eslint-enable */\n\n    return isReducerInjected && isSagaInjected ? props.children : null;\n  }\n\n  Manager.displayName = name;\n  return Manager;\n}\n\nexport { SagaInjectionModes, createInjectorsEnhancer, createManager, forceReducerReload, injectReducer, injectSaga, useInjectReducer, useInjectSaga };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}